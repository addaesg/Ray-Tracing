# A simpler UML diagram for designing mid-complexity software

The diagram is a simpler and more permissive version of a software UML diagram. Each node may be either a class or interface, containing properties and methods, or a procedure described either in pseudocode or in plain natural language.

The UML specification defines many relationships between classes, but the only one we use is the dependency relationship, and we allow this relationship to take place between any pair of nodes, not only between classes/interfaces.
So, if there exists an arrow from a node A to a node B, then the implementation/codification of A depends on the implementation of B, so that we must first implement B and then use it on the implementation of A.

The strategy for creating the diagram in then start by defining the _root node(s)_ (which we can also call the _goal node(s)_). This is the ultimate procedure the program must implement, i.e., what the program will be built for, very generally, but precisely, described. (On our diagram, this node is the blue, bottom-most one.) Call this root node R. Next, we think about what we need to know how to do beforehand in order to be able to implement R with ease. That is, we think, "What classes or procedures A, B, C... would make it very easy and straightforword to implement R by simply combining together these A, B, C..., assuming we have already found a way of implementing A, B, C...?" We then think of convinient classes or procedures A, B, C... so that the implementation of R directly follows from them, and then we create nodes for A, B, C... and draw dashed arrows from R to them.

Notice that this breaks up the task of implementing the complex node R into first implementing multiple simpler nodes A, B, C... and then merging them together into R. Notice also that, because we choose A, B, C... so that this merging task is very simple, we need not explicitly write in the diagram how to merge them into R: this information is always evident, or very simple to deduce, from the descriptions of A, B, C... and R themselves. (If, on the first try, this how-to-merge information doesn't seem that obvious, then it means that A, B, C... were not chosen properly, so we should either change them or create additional nodes D, E... that will then make the merging task simpler and more evident).

After we have broken up the task of implementing R like that, we then repeat the very same procedure with all nodes A, B, C..., breaking up each one of them into even simpler nodes, and so on. We repeat this until we have found nodes L<sub>1</sub>, L<sub>2</sub>... that are so damn simple to implement that it doesn't make sense anymore to further break them up into simpler functionalities: we could just code L<sub>1</sub>, L<sub>2</sub>... straightaway, without further ado, because it is very obvious how to do so.

These L<sub>1</sub>, L<sub>2</sub>... are the leaf nodes, which point nowhere (don't depend on any node). The whole software ultimately depends on them, and we start the development by writing them.

After the diagram is ready, we use it as a reference for coding the whole software. We have found that this is a very efficient way of developing mid-complexity software, leading to less bugs and development time.
